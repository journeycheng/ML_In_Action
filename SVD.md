## SVD

### 1. 矩阵分解

1.1导入相关库
```python
from numpy import *
from numpy import linalg as la
```

1.2数据集

```python
def loadExData():
  return[[0, 0, 0, 2, 2],
         [0, 0, 0, 3, 3],
         [0, 0, 0, 1, 1],
         [1, 1, 1, 0, 0],
         [2, 2, 2, 0, 0],
         [5, 5, 5, 0, 0],
         [1, 1, 1, 0, 0]]
```
1.3进行矩阵分解
```python
data = loadExData()
U,Sigma,VT = la.svd(data)
```

```python
>>> U
array([[  0.00000000e+00,   5.34522484e-01,   8.37548868e-01,
          1.01909305e-01,   4.91131461e-02,   6.52171142e-17,
         -2.39321450e-17],
       [  0.00000000e+00,   8.01783726e-01,  -4.90973792e-01,
         -2.70288776e-01,   2.07440522e-01,   3.05311332e-16,
         -6.93889390e-17],
       [  0.00000000e+00,   2.67261242e-01,  -2.02176360e-01,
          6.07047720e-01,  -7.20547857e-01,  -9.84967805e-16,
          2.20308414e-16],
       [ -1.79605302e-01,   1.85980476e-17,   4.72088531e-02,
         -2.71408992e-01,  -2.41903050e-01,   8.95649199e-01,
         -1.76481855e-01],
       [ -3.59210604e-01,   3.71960953e-17,   9.44177062e-02,
         -5.42817984e-01,  -4.83806099e-01,  -4.44717778e-01,
         -3.68183963e-01],
       [ -8.98026510e-01,   1.06817028e-17,  -5.66506237e-02,
          3.25690790e-01,   2.90283659e-01,   3.49368814e-16,
         -9.13994065e-17],
       [ -1.79605302e-01,   1.85980476e-17,   4.72088531e-02,
         -2.71408992e-01,  -2.41903050e-01,  -6.21364261e-03,
          9.12849782e-01]])
```
```python
>>> Sigma
array([  9.64365076e+00,   5.29150262e+00,   7.17576917e-16,
         7.36147444e-17,   1.74873814e-33])
```
矩阵Sigma以行向量的形式返回，因为只有对角线元素非零。前两个值比其他值大了很多，于是可以将最后三个值去掉


Sigma计算能量
```python
>>> SigEnergy = Sigma**2
>>> sum(SigEnergy)
121.0
```
再计算总能量的90%：
```python 
>>> sum(SigEnergy) * 0.9
108.90000000000001
```

计算前两个元素所包含的能量：
```python
>>> sum(SigEnergy[:2])
121.0
```
该值高于总能量的90%。

```python
>>> VT
array([[ -5.77350269e-01,  -5.77350269e-01,  -5.77350269e-01,
          0.00000000e+00,   0.00000000e+00],
       [ -2.16480700e-16,   1.08240350e-16,   1.08240350e-16,
          7.07106781e-01,   7.07106781e-01],
       [ -7.18866271e-01,   2.41370514e-02,   6.94729219e-01,
         -1.83624811e-16,  -2.39135962e-16],
       [ -3.87166569e-01,   8.16139736e-01,  -4.28973168e-01,
         -7.02311690e-17,   4.07911335e-17],
       [  0.00000000e+00,   1.10582250e-16,  -1.10582250e-16,
         -7.07106781e-01,   7.07106781e-01]])
```
用上面三个矩阵相乘得到原始数据集的一个近似.

先构建一个2\*2的矩阵Sig2
```python
Sig2 = mat([[Sigma[0], 0], [0, Sigma[1]]])
```
```python
>>> U[:, :2]*Sig2*VT[:2, :]
matrix([[ -6.12299885e-16,   3.06149942e-16,   3.06149942e-16,
           2.00000000e+00,   2.00000000e+00],
        [ -9.18449827e-16,   4.59224914e-16,   4.59224914e-16,
           3.00000000e+00,   3.00000000e+00],
        [ -3.06149942e-16,   1.53074971e-16,   1.53074971e-16,
           1.00000000e+00,   1.00000000e+00],
        [  1.00000000e+00,   1.00000000e+00,   1.00000000e+00,
           6.95875223e-17,   6.95875223e-17],
        [  2.00000000e+00,   2.00000000e+00,   2.00000000e+00,
           1.39175045e-16,   1.39175045e-16],
        [  5.00000000e+00,   5.00000000e+00,   5.00000000e+00,
           3.99672720e-17,   3.99672720e-17],
        [  1.00000000e+00,   1.00000000e+00,   1.00000000e+00,
           6.95875223e-17,   6.95875223e-17]])
```

### 2.基于协同过滤的推荐引擎

相似度计算(参数都必须为整型)
- 基于欧式距离
```python
def ecludSim(inA,inB):
    return 1.0/(1.0 + la.norm(inA - inB))
```
- 基于皮尔逊系数
```python
def pearsSim(inA,inB):
    if len(inA) < 3 : return 1.0
    return 0.5+0.5*corrcoef(inA, inB, rowvar = 0)[0][1]
```
检查是否存在3个或更多的点。如果不存在，该函数返回1.0，这是因为此时两个向量完全相关。

－ 基于余弦
```python
def cosSim(inA,inB):
    num = float(inA.T*inB)
    denom = la.norm(inA)*la.norm(inB)
    return 0.5+0.5*(num/denom)
```
测试一下

```python
>>> data = mat(data)
>>> ecluSim(data[:, 0], data[:, 4])
0.12973190755680383
```
第一列与第二列数据的欧式距离相似度为0.129732

```python
>>> cosSim(data[:, 0], data[:, 4])
0.5
```
余弦相似度为0.5

```python
>>> pearsSim(data[:, 0], data[:, 4])
0.20596538173840329
```
基于皮尔逊系数相似度为0.205965
